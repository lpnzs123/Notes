<h2><span style="font-family: 黑体, 'Heiti SC'; font-size: 14pt;"><strong>一、zset类型（有序集合）</strong></span></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.zset即在set的基础上，每个val值前加一个score分数值。它也是一个复合类型，即键：值，值中又是一个键值对。例如：k1 score1 v1 score2 v2，sorce作为分数，也是zset集合的排序参考</span></p>
<p><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.1）zadd zset01 20 v1 30 v2 10 v3即添加一个zset集合，其中包含了三个值20 v1 30 v2 10 v3，每个值都是一个键值对（前面是分数后面是值）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）zrange zset01 0 -1即遍历zset01（按照元素分数从小到大遍历），zrange zset01 0 -1 withscores带着分数遍历zset01（按照元素分数从小到大遍历），zrevrange zset01 0 -1 withsorces即遍历zset01（按照元素分数从大到小遍历）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）"zrangebyscore zset01 60 90"即将分数在60到90的值（x为我们遍历出的分数值，遍历范围为60&lt;=x&lt;=90）遍历出来并进行排序，"zrangebyscore zset01 (60 90" 即将分数在60到90的值遍历出来并进行排序（x为我们遍历出的分数值，遍历范围为60&lt;x&lt;=90）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">"zrangebyscore zset01 (60 90 limit 0 2"即将分数在60到90的值遍历出来并进行排序（x为我们遍历出的分数值，遍历范围为60&lt;x&lt;=90）得到结果集合，将以上得到的集合取出前两个进行显示</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：若limit为1到2，则取出结果集合的第二个值进行显示</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4)zscore zset01 v1即获取集合zset01值为v1对应的分数</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）zcard zset01即获取集合zset01中键值对的数量</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">6）zrem zset01 v1即删除集合zset01中值为v1 的键值对</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">7）zincrby zset01 3 v1即集合zset01中值为v1的键值对的分数加3分</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">8）zcount zset01 60 100即获取集合zset01集合中大于等于60分小于等于100分的键值对个数</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">9）zmpop 1 zset01 min|max count 2即弹出1个指定的集合zset01的"最小|最大"的两个数</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">10)zmpop 2 zset01 zset02 min|max count 3即弹出2个指定的集合zset01和zset02中的3个"最大|最小"的元素。从zset01开始弹出，zset01没有可以弹出的元素则从zset02中选取元素弹出，注意zset01和zset02在命令行中的先后顺序</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：若zset01中只有一个元素了，但是在zmpop 2 zset01 zset02 min|max count 3命令行中，我们会从zset01中弹出"最大|最小"的3个元素，此时不会将zset01中的一个元素与zset02中的"最大|最小"的2个元素一并弹出，而是仅弹出zset01中仅剩的一个元素</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">11）zrank zset01 v2即查出值为v2键值对在集合zset01中下标的位置（从小到大，从左到右）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">12）zrevrank zset01 v2即查出值为v2键值对在集合zset01中下标的位置(从大到小，从右到左)</span></p>
<p>&nbsp;</p>
<h2><strong><span style="font-family: 黑体, 'Heiti SC'; font-size: 14pt;">二、位图（bitmap）类型</span></strong></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.位图即由0和1状态表现的二进制位的bit数组。位图的底层是由string类型实现的，所以type 位图类型时，返回的值是string</span></p>
<p><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.1）setbit k1 1 0即设置位图k1中第二位值为0（注意，位图中存储的值只可以是0或者1）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）getbit k1 0即查询位图k1中第一位值是多少</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）strlen k1（假设k1中数据为100000011）即统计位图k1中数据字节数占用多少，k1的字节数占用为2byte（注意这里是字节数）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：位图中可以存很多个0和1，但是8位一组，即8个bit一组（等于一个字节）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）bigcount k1（假设k1中数据为100000011）即统计位图k1中含有多少个1，k1中含有3个1</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）假设存在两个位图k1和k3，其中分别记录了在某一天（两个位图记录的不是同一天而是连续的两天）用户观看某一个视频的记录（0为未观看，1为已观看），现在我们要查询出连续两天观看同一视频的用户有几个。可以使用命令bitop进行统计，用例如下：</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">bitop and k3 k1 k2即将k1和k2位图做与操作赋值给位图k3，使用bigcount可以计算出我们需要的结果</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：bitop and k3 k1 k2并不会返回我们需要的结果，而是返回操作是否成功，具体的结果要查询k3才能得知</span></p>
<p>&nbsp;</p>
<h2><strong><span style="font-family: 黑体, 'Heiti SC'; font-size: 14pt;">三、基数统计（HyperLogLog）类型（本质是string类型）</span></strong></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.1）UV即unique visitor独立访客，也可以理解为客户端ip</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）去重复又拥有统计功能的基数估计算法即基数统计（HyperLogLog），HyperLogLog类型不可以返回输入的各个元素（即不可遍历）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）基数统计即用于统计一个集合中不重复的元素个数，就是对集合去重后剩余元素个数的计算</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：基数统计（HyperLogLog）类型可以返回基数估计值，注意是估计，也就是存在误差，但是这个无差往往是可以接受的</span></p>
<p><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.1）pfadd hll01 1 3 5 7 9 9即设置一个基数统计类型hll01</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）pfcount hll01即返回基数统计类型hll01去重后的元素个数</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）pfmerge result hll01 hll02即将基数统计类型hll01和hll02合并并计算出基数估计值，将结果存入基数统计类型result中</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：可通过pfcount result查询出其中去重后的元素个数</span></p>
<p>&nbsp;</p>
<h2><span style="font-size: 14pt;"><strong><span style="font-family: 黑体, 'Heiti SC';">四、地理空间类型（GEO）</span></strong></span></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.属于一个复合类型，即键值对中的值又是一个键值对，本质上是一个zset类型</span></p>
<p><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.1）"geoadd city 经度01 纬度01 local01 经度02 纬度02 local02"即设置一个geo类型，键为city，其中的值有两个，分别是local01、local02（这两个为值中的键）.他们对应的经度纬度分别为"经度01 纬度01"和"经度02 纬度02 local02"</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）zrange city 0 -1即遍历查询geo类型键值对中值中的键</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：redis的中文乱码问题可以在登录的时候使用"redis-cli -a 密码 --raw"命令行</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）geopos city local01 local02即返回geo类型city的值local01、local02分别对应的经纬度</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）geohash city local01 local02即将geo类型city值local01、local02对应的经纬度经过转换，返回一个hash映射值。每个hash映射值对应响应的经纬度（数字表示的经纬度），使得我们不再关注经纬度长而又繁杂的数字本身，相当于取别名</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）"geodist city local01 local02 [km|m|ft|mi]"即计算geo类型city中local01和local02两个位置间的距离</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：km千米、m米、ft英尺、mi英里</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">6）"georadius city 经度01 纬度01 10km withdist withcoord withhash count 10 desc"即返回geo类型中以"经度01 维度01"为中心，半径10km的位置元素。withdist即返回位置元素的同时计算对应位置元素与中心的距离并返回（单位为给定半径的单位），withcoord即返回位置元素的同时将位置元素的经纬度也返回，withhash即返回位置元素的同时也返回经过原始geohash编码的有序集合分值，用处不大。count则为限定返回的记录数，desc即以降序排列</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">7）"georadiusbymember city local03 10km withdist withcoord withhash count 10 desc"大体上个georadius命令相同，但是这里的中心不是用经纬度设置了，而是用geo类型city中的值local03来作为中心</span></p>