<h2><span style="font-family: 黑体, 'Heiti SC'; font-size: 14pt;"><strong>一、Stream类型（本质上是stream类型，即我就是我）</strong></span></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.redis-stream即redis版本的MQ，stream类型也是一个复合结构，即键值对中值又是一个键值对</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.stream类型的结构</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）MessageContent：消息内容</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：生产者将消息放入消息队列中</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）ConsumerGroup：消费者所组成的小组，即消费组</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）Last_delivered_id:每个消费组都由一个游标，任意一个消费者读取了消息都会使得游标向最新发布的消息的方向移动</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）Consumer：消费者</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）Pending_ids:每个消费者都会有的一个状态变量，用于记录被当前消费已读取但是并未确定（ack）的消息ID。这个属性用于确保哦客户端至少消费了消息一次，而不会在网络传输的过程中丢失了没有处理</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3.生产者相关指令（包含了部分消费者）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）&ldquo;xadd mystream01 *|id cname sekiro age 21&rdquo;即生成一个Stream类型键为mystream01。*表示由redis为消息自动指定消息id，也可以不用*自己指定消息i，后面的"cname sekiro age 21"可以看作对象的属性与属性对应的值，上述命令行执行完成后会返回消息id，并将消息放入消息队列之中</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：redis对消息ID有要求，即格式必须是"unix时间戳-自增id&ldquo;的格式，且后续的消息ID不能小于前一个消息ID</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）&rdquo;xrange mystream01 - + count 1&ldquo;即将Stream类型mystream01中的消息按消息ID从小到大遍历显示，但只返回1条消息记录。-代表最小值，+代表最大值，也可以自己指定遍历范围</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）"xrevrange mystream01 + -"即反方向的遍历，按消息ID从大到小</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）"xdel mystream01 消息ID"即按消息ID删除Stream类型mystream01中对应的消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）xlen mystream01 即返回Stream类型mystream01中有几条消息，由此可见，mystream01是一个消息队列</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">6）xtrim mystream01 maxlen 2 即对Stream类型mystream01进行消息截取，保留消息ID时间戳最大的两个消息，其余的被截掉</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">7）"xtrim mystream01 minid 消息ID"即对Stream类型mystream01进行消息截取，截掉比给定消息ID时间戳更小的消息ID对应的消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">8）&rdquo;xread count 2 streams mystream01 $&ldquo;即获取消息（非阻塞），返回Stream类型mystream01队列中大于指定消息ID（这里是$）的2条消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">9）&rdquo;xread count 2 streams mystream01 0-0&ldquo;即获取消息（非阻塞），返回Stream类型mystream01队列中大于指定消息ID（这里是0-0）的2条消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">10)"xread count 1 block 0 streams mystream01 $"即获取消息（阻塞），返回Stream类型mystream01队列中大于指定消息ID（这里是$）的1条消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">11）"xread count 1 block 1000 streams mystream01 $"即获取消息（阻塞），返回Stream类型mystream01队列中大于指定消息ID（这里是$）的1条消息。1000为block的阻塞时间（单位为毫秒），若超时未收到消息信息，则返回nil（即null）或什么也不返回。该命令行是同步执行的</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）默认读取时非阻塞</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）这里面的$表示消息队列中消息ID最大的一条消息的ID</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）streams是命令行中的关键字，固定写死</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）这里面的0-0表示从最小的消息ID开始获取Stream队列中的消息，如果不指定count则返回队列中所有的消息（使用000也行）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）block表示是否以阻塞的方式读取消息，后面接阻塞时间，若为0则表示永远阻塞</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">6）生产者通过xadd向stream队列发送消息，消费者通过xread从stream队列拉取消息</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4.消费者相关指令</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）"xgroup create mystream01 分组名称   $|0-0"即为Stream类型mystream01队列创建消费者组</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）"xreadgroup group 分组名称 消费者名称 streams mystream01 &gt;"即为分组创建消费者，并在队列mystream01中从头到尾读取全部数据，&gt;表示从第一条尚未被消费的消息开始读取</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）"xreadgroup group 分组名称 消费者名称 count 2 streams mystream01 &gt;"即为分组创建消费者，消费者从mystream01消息队列第一条尚未被消费的消息开始读取2条消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）这里面的$表示从Stream类型mystream01队列尾部开始消费，0-0表示从Stream类型mystream01队列头部开始消费</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）消费顺序从头到尾，这里面的$也表示消费者组只会消费最新的消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）stream队列中的消息一旦被消费者组中的某个消费者消费过了，那么这个消费者同组的其他消费者，就不能再消费这个消费者读取过的同一条消息了，即同一组的消费者不能消费同一条消息。但是，不同消费组的消费者是可以消费到同一条消息的。这样的一个特点可以让我们实现负载均衡，即限定一个消费者组内的消费者读取几条信息，从而将消息队列中的消息全部读完，并且可以保证组内的每个消费者读取消息不重复</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5.ack确认机制（以上消费者读取消息仅仅只是读取消息，并未ack，即确认）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）"xpengding mystream01 消费者分组名称"即返回消费者分组中已读取消息但是并未确认的消费者以及消费者对应读取消息的条数、消费者读取消息的最小消息ID、消费者读取消息的最大消息ID，消费者组读取消息的总数</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）"xpending mystream01 groupA - + 10 consumer1"即查询消费者组groupA中消费者consumer1按消费ID从小到大（-到+）消费的10条消息ID（若consumer1仅消费了两条消息，则仅查询出两条消息的消息ID）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）"xack mystream01 groupA 消息ID"即对已经被groupA消费者组中消费者读过的消息进行确认，消费者组groupA读取的是消息队列mystream01中的消息</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）"xinfo stream mystream01"即用于打印消息队列mystream01中的详细信息，xinfo stream固定写死</span></p>
<p>&nbsp;</p>
<h2><span style="font-family: 黑体, 'Heiti SC'; font-size: 14pt;"><strong>二、bitfield位域类型</strong></span></h2>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1.1）bitfield位域即将一个redis字符串看作是由一个二进制位组成的数组，并可以对 变长位宽 和 任意没有字节对齐的指定整形位域 进行寻址和修改</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）bitfield位域类型可以做到位域修改和溢出控制</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2.1）下面案例均以此命令行为基础：set fieldkey hello</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）hello的二进制数为：01101000 01100101 01101100 01101100 01101111</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3.1）"bitfield fieldkey get i8 0"即bitfield将键fieldkey对应的字符串值看作了一个二进制位组成的数组，"get i8 0"即取出这个二进制数组有符号的8位数字，且从头开始（即从第一位下标为0的数字开始）取，取出的结果按十进制表示</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）"bitfield fieldkey set i8 8 120"即将fieldkey对应的字符串对应的二进制数组从第9位开始的后8位有符号数改成我们设置的十进制对应的英文字母x。此时fieldkey对应的字符串为"hxllo"</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）"bitfield fieldkey incrby u4 2 1"即fieldkey对应的字符串对应的二进制数组从第3位开始的后4个无符号整型开始加1（注意，这里是对4个无符号的整型整体加1，也可以看成对4位无符号整型转换成十进制后加1）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）默认什么提示也没有的溢出为循环溢出（wrap），这也是默认的溢出控制方法</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）"bitfield fieldkey overflow sat set i8 0 128"即将fieldkey对应的字符串对应的二进制数组从第一位（下标为0）开始的后8位有符号整型设置为十进制128对应的ascii码字符，溢出控制使用sat（指定溢出控制方法的关键词时overflow）。SAT类型的溢出控制，下溢（负数）出的结果计算为最小整数值，上溢（正数）出的结果计算出为最大整数值，因此，此时的fieldkey对应的字符串对应的二进制数组的前8位对应的十进制位127</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">6）"bitfield fieldkey overflow fail set i8 0 128"即将fieldkey对应的字符串对应的二进制数组从第一位（下标为0）开始的后8位有符号整型设置为十进制128对应的ascii码字符，溢出控制使用fail，fail即溢出时拒绝执行并返回nil（null）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">注：</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">1）在redis中，有符号整型需要在位数前加一个i，无符号整型需要在位数前加个u。例如u8是一个8位的无符号整型，i16是一个16位的有符号整型</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">2）字符串中每一个英文字符都是1byte即8bit（按照ascii码来的，在ascii码文件中一个英文字母占一个字节）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">3）英文字母x的十进制为120 </span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">4）incrby命令会造成循环溢出（wrap），例如上面的四进制数加到15（十进制）时，再加1四进制数便会溢出（因为四进制最多表示0到15）</span><br /><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">5）8位数在十进制内的范围时 -128到127</span></p>
<p><span style="font-family: 宋体, 'Songti SC'; font-size: 18px;">&nbsp;</span></p>