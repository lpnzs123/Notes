# Mysql是怎样运行的：第七章笔记

---

## 前言

---

前几章的笔记没有书写了，当初看一遍就过去了，现在开始亡羊补牢。对于偏概念的书籍，阅读的时候还是得做好相关的笔记。毕竟因为各种原因，阅读可能中途中断，这个时候，笔记就是帮助我们快速回溯过往知识，为学习新知识做准备的利器。

至于前几章的笔记，这本书我会阅读第二遍的，以后再补全吧。

对了，本章的笔记也是残缺不全的，先将就一下吧。

<br/>

## 回忆一些旧知识

---

### 数据页

---

InnoDB 为了不同的目的而设计了许多种不同类型的页。我们聚焦讨论的是存放我们表中记录的那种类型的页，他有个官方名称名为**索引页（INDEX 页）**，非官方名称为**数据页**。

<br/>

### 数据页之间与数据页内部记录之间的关系

---

数据页之间用双向箭头链接，即双向链表。数据页内部记录之间用单项箭头链接，即单向链表（数据页内部记录按照主键值从小到大的顺序用单向箭头链接）。

数据页之间可以不在物理结构上相连，只通过双向链表相关联即可。

<br/>

### 页目录

---

如何根据主键值在数据页中快速的查询某条记录？页目录会给出答案。页目录就像书籍的目录，可以帮助我们进行快速的定位。

<br />

页目录的构建过程如下：

1. 将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 n_owned 属性表示该记录拥有多少条记录，即该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页尾部的地方，这个地方就是所谓的 Page Directory ，也就是页目录。页目录中的这些地址偏移量被称为槽（英文名：Slot），所以这个页目录就是由槽组成的。

**注意：页目录存放槽的顺序是按照组号从小到大的顺序取出每个组最后一条记录的地址偏移量从右到左的进行存放。也就是说，页目录的槽号从右到左逐渐递增。**

<br />

因为数据页内部记录按照主键值从小到大的顺序用单向箭头链接，所以每个组的最后一条记录，是组内主键值最大的记录，由此可以使用二分法进行记录的查找。

<br/>

### 索引

---

以主键值查找记录可以使用页目录利用二分法进行快速的查找，但是对于非主键值呢？他们可没有页目录，难道我们遍历所有的记录来进行查找？显然，对于数据量庞大的情况并不现实。

为了解决上面的情况，我们想建立一个查找目录，这个目录与页目录有一定的相似但又完全不同，查找目录中的每一项对应相应的数据页。

前面我们说过，数据页之间并不一定在物理结构上相连，从数据页的编号来看，页 9 的下一个数据页的编号可能是页 28 ，也可能是页 3 。

数据页在物理结构上不一定相连也就决定了我们不可以单纯的根据页号建立对应的查找目录（因为我们想像页目录那样利用二分法进行查找）。

那怎么办呢？至少根据目前的分析来看，我们需要满足一点，就是我们建立的查找目录的目录项在物理存储器上应该是连续存储的。

其次，目录项之间的关系对应到数据页上，应该满足一个条件，对于特定的字段，后一个数据页第一个记录对应的字段值应该比前一个数据页最后一个记录对应的字段值大（至于怎么个大法，看比较规则咯）。

最后，我们可以根据以上两点构建出一个简单的查找目录，其中每一个目录项包含的数据如下：

* 数据页第一个记录的特定字段值。
* 数据页页号。

现在，我们就可以根据特定字段值利用二分法查找到对应的页号，最终找到对应的记录了。

我们所建立的查找目录，就是一个简单的索引。

<br/>

### 目录项记录

---

我们明白了简单的索引的构成，现在我们要扩展它。InnoDB 中的索引方案，是上面简单索引的延伸。

InnoDB 复用了之前存储用户记录的数据页来存储目录项，为了和用户记录做一下区分，我们把这些用来表示目录项的记录称为**目录项记录**。

目录项记录只有主键值和页的编号（页号）两个列（对于聚簇索引而言），而普通的用户记录的列是用户自己定义的，可能包含很多列，另外还有 InnoDB 自己添加的隐藏列。

<br/>

### 聚簇索引

---

InnoDB 存储引擎会自动的为我们创建聚簇索引，在 InnoDB 存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），即**索引即数据，数据即索引**。

<br />

聚簇索引是这样一个 B+ 树，它具有两种特性：

1. 使用记录主键值的大小进行记录和页的排序，即
   * 从数据页记录来看，页内的记录是按照主键的大小顺序排成一个单向链表。
   * 从数据页来看，各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   * 从目录项记录来看，存放目录项记录的页分为不同的层次（B+ 树的层次），在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. B+ 树的叶子节点存储的是完整的用户记录（这一点看过数据结构的应该都明白）。

<br />

为什么存放目录项记录的页会分为不同的层次（层次也可以理解成目录级别）？可以这么想，当数据量足够庞大的时候，仅仅靠一层存放目录项记录的页（一级目录）已然不够，这时候由于数据量的庞大导致的存放目录项记录的页的数量庞大，已经对查找速度造成一定的影响。有什么办法可以解决这个问题？当然是生成一个更高级的层次（二级目录），这时，B+ 树的层次就会增加一层。

<br/>

### 二级索引

---

为了解决我们想用非主键列进行查找的问题，二级索引被顺势提出。

<br />

二级索引亦是一棵 B+ 树，与聚簇索引相似，但是亦有不同：

1. 目录项记录中不再是 主键 + 页号 的搭配，而变成了 非主键列 + 页号 的搭配。
2. 既然想使用对应的非主键列进行查找，并且目录项记录的内容成为了 非主键列 + 页号，那么可以明显得知，被选中建立索引的非主键列的值是可以进行比较的。从而延伸出二级索引和聚簇索引新的不同点。二级索引使用记录非主键列的大小进行记录和页的排序：
   * 从数据页记录来看，页内的记录是按照非主键列的大小顺序排成一个单向链表。
   * 从数据页来看，各个存放用户记录的页也是根据页中记录的非主键列大小顺序排成一个双向链表。
   * 从目录项记录来看，存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的非主键列大小顺序排成一个双向链表。
3. 二级索引 B+ 树的叶子节点存储的并不是完整的用户记录，而只是 非主键列 + 主键 这两个列的值。

<br />

二级索引的构成注定了在利用非主键值查找到指定的二级索引叶子节点的数据后，还要进行一次**回表**的操作。何谓回表？就是利用聚簇索引再查一次。还记得二级索引叶子节点的内容构成吗？非主键列 + 主键 ，也就是说，我们利用二级索引进行查找，最后会得出一个主键值，这个主键值就是我们进行回表的关键数据，因为聚簇索引就是根据主键值查找对应完整记录的。因为回表的操作，二级索引又被称为辅助索引。很明显，我们的二级索引根据非主键列而建立，假设这个非主键列为 c2 ，我们也称这个二级索引（B+ 树）为 c2 列建立的索引。

<br/>

### 联合索引

---

联合索引本质上是二级索引，只不过它以多个非主键列建立了一个二级索引。

上文中我们说过，想使用对应的非主键列进行查找，被选中建立索引的非主键列的值是可以进行比较的。联合索引选中了多个非主键列建立一个二级索引，也就意味着有多个排序规则，这些排序规则按照被选中的非主键列的顺序依次生效。例如，我依次选中 c2、c3 两个非主键列建立联合索引，那么联合索引对应的 B+ 树的排序规则为：

* 先把各个记录和页按照 c2 列进行排序。
* 在记录的 c2 列相同的情况下，采用 c3 列进行排序。

对应目录项记录的内容结构为：c2 + c3 + 页号。

联合索引对应的 B+ 树叶子节点处的用户记录由 c2、c3 和主键 c1 列组成。

<br/>

## 笔记正文

---

### 回表的代价

---

以数据页记录为例，若记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为**顺序I/O**。记录随机分布在不同的数据页中，这样读取完整的记录可能要访问很多的数据页，这种读取方式我们也可以称为**随机I/O**。一般而言，顺序I/O比随机I/O的性能高很多。

<br/>

回表操作并不一定可以提升性能，恰恰相反，在某些情况下会使得性能大大降低。二级索引回表的记录越多，其性能就越低。打个比方，如果需要回表的记录数占总记录数的 90% 以上，这时候进行回表，不是吃力不讨好？这时候查询优化器就会选择全表扫描（扫描聚簇索引）。

<br/>

我们可以采取限制返回的记录数的方式（LIMIT 关键字）来提高 二级索引 + 回表 扫描方式在查询优化器选择 二级索引 + 回表 扫描方式还是 全表扫描 扫描方式时的权重。因为回表的记录越少，性能提升就越高。

<br/>

### 覆盖索引

---

回表的性能消耗在查询的查询列表只包含索引列的时候被消除，这时候就算不限制返回的记录数，也能获得很高的性能。当然，具体情况具体分析，如果业务需要查询除索引以外的字段，那肯定优先保证业务需求。

不鼓励使用 * 号作为查询列表，最好把我们需要查询的列依次标明。

<br/>

### 如何挑选索引（建立索引与编写查询语句的注意事项）

---

1. 只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的列创建索引，而出现在查询列表中的列就没必要建立索引了。

2. 最好为那些列的基数（列的基数即某一列中不重复数据的个数）大的列建立索引，为基数太小列的建立索引效果可能不好。因为重复的数据无法排序，那就无法进行快速查找了。而且重复的数据量庞大的话可能伴随着大量的回表操作，得不偿失。

3. 索引列的类型尽量小。即在表示的范围允许的情况下，应尽量让索引列使用较小的类型，比如我们能使用 INT 就不要使用 BIGINT 。好处如下：

   * 数据类型越小，在查询时进行的比较操作越快。
   * 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率，减少磁盘 I/O 带来的性能损耗。

   索引的实际运用中，不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值。如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O 。由于以上原因，这个建议对于表的主键来说更加适用。

4. 只索引字符串值的前缀，尤其是在字符串类型能存储的字符比较多的时候。例如：

   ```mysql
   CREATE TABLE person_info(
       name VARCHAR(100) NOT NULL,
       birthday DATE NOT NULL,
       phone_number CHAR(11) NOT NULL,
       country varchar(100) NOT NULL,
       -- name(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码
       KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
   );    
   ```

   当我们为字符串列建立索引时，要考虑两个问题，分别是时间和空间。上文的为非主键列建立索引告诉我们，我们为字符串列建立索引时，若将完整的字符串作为二分法比较的键，当字符串很长时，占用的存储空间和比较的时间，都会十分巨大。因此，以一定长度的字符串前缀作为二分法比较的键，虽然查找的精度不够，但是我们可以根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样即节省了空间，又节约的时间。

   **注意：使用索引列前缀的方式无法支持使用索引排序，因为其不包含字符串值的完整信息。**

5. 如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。例如：``WHERE my_col * 2 < 4``。

6. 让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入。这样做是为了避免插入的主键忽大忽小而造成的数据页满的时候的页面分裂和记录移位带来的性能损耗。

   **注意：对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在聚簇索引的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序。**

7. 不要冗余和重复索引，冗余和重复索引会增加维护成本。例如：

   

   ```mysql
   CREATE TABLE person_info(
   	...
   	-- 冗余索引，对 name 列而言   
   	KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
   	KEY idx_name (name(10))
   	...
   );    
   ```

   <br />

   ```mysql
   CREATE TABLE repeat_index_demo (
    	-- 重复索引，对 c1 列而言    
   	c1 INT PRIMARY KEY,
   	c2 INT,
   	UNIQUE uidx_c1 (c1),
   	INDEX idx_c1 (c1)
   );  
   ```

   <br />

8. B+ 树索引在空间和时间上都有代价，不要动不动就建立索引。

9. 尽量使用覆盖索引进行查询，避免回表带来的性能损耗。

<br />

## 题外话

---

### 笔记规则

---

1. 所有非中文字符（如 英语单词）和中文字符组成的表达式（如 主键 + 页号），在他们的两端都要加上空格，除非整个句子以他们开头或者结尾。若是以他们开头，则在他们的结尾处加上空格。若是以他们结尾，则在他们的开头处加上空格。
2. 连续的段落之间，若两个段落均超过了两行 或 等于两行 或 其中一段等于两行另一个为一行，则需要在他们之间用 `<br />`进行分隔（必须）。若两个段落均为一行，则可选在他们之间是否加上`<br />`进行分隔。
3. 句子以 `。` 结尾，不可以省略。
4. 除了代码，尽量不要使用代码块的形式（markdown 的 \`\`\`内容\`\`\`）包裹内容，单行代码块（markdown 的 \`内容\`）也不行。
5. 标题的下面必须有分割线。
