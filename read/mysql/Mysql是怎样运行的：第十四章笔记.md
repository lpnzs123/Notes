# Mysql是怎样运行的：第十四章笔记

---

## 前言

---

根据一定的规则，将执行起来十分耗费性能的语句重写成某种可以以比较高效率执行的形式，这个过程便是**查询重写。**

本章将围绕着查询重写中较为重要的一些**重写规则**展开论述。

<br />

## 条件化简

---

查询语句的搜索条件本质上是一个表达式，若该表达式繁杂抑或是低效，MySQL 的查询优化器就会为我们简化这些表达式。

化简的方式如下（a，b，c等字母均代表列名）：

* 移除不必要的括号。例如

  ```mysql
  -- 化简前
  ((a = 5 AND b = c) OR ((a > c) AND (c < 5)))
  
  -- 化简后
  (a = 5 and b = c) OR (a > c AND c < 5)
  ```

* 常量传递（Constant_Propagation）。即表达式是某个列 a 和某个常量做等值匹配，并且该表达式和其他涉及列 a 的表达式用关键字 AND 连接，那么就可以将其他涉及列 a 的表达式中 a 的值替换成做等值匹配的常量值。例如：

  ```mysql
  -- 化简前
  a = 5 AND b > a
  
  -- 化简后
  a = 5 AND b > 5
  ```

* 等值传递（Equality_Propagation）。例如：

  ```mysql
  -- 化简前
  a = b and b = c and c = 5
  
  -- 化简后
  a = 5 and b = 5 and c = 5
  ```

* 移除没用的条件（Trivial_Condition_Removal）。明显永远为 TRUE 或 FALSE 的表达式，优化器会移除他们。例如：

  ```mysql
  -- 化简前
  (a < 1 and b = b) OR (a = 6 OR 5 != 5)
  
  -- 化简后
  a < 1 OR a = 6
  ```

* 表达式计算。即查询执行之前，若表达式中只包含常量，则它的值会被先计算，例如：

  ```mysql
  -- 化简前（注意到表达式右边只包含常量）
  a = 5 + 1
  
  -- 化简后
  a = 6
  ```

  但是，如果列并不是以单独的形式作为表达式的操作数，那么优化器是不会尝试对这些表达式进行化简的。例如：

  ```mysql
  -- 列出现在函数中
  ABS(a) > 5
  
  -- 列出现在复杂的表达式中
  -a < -8
  ```

  我们知道，只有搜索条件中索引列和常数使用某些运算符连接起来才可能使用到索引，所以如果可以，**最好让索引列以单独的形式出现在表达式中。**
  
* HAVING 子句和 WHERE 子句的合并。即若查询语句中没有出现聚合函数（例如 SUM、MAX等）以及 GROUP BY 子句，那么查询优化器就会将 HAVING 子句和 WHERE 子句合并。

* MySQL 认为以下两种查询速度特别快：

  * 查询的表中无记录或只有一条记录。
  * 使用主键等值匹配或者唯一二级索引列等值匹配作为搜索条件来查询某个表。

  这里的问题是，我们怎么在查询前知道查询的表中无记录或只有一条记录呢？当然是通过统计数据只晓的。不过我们说过InnoDB的统计数据数据不准确，所以这一条不能用于使用InnoDB作为存储引擎的表，只能适用于使用Memory或者MyISAM存储引擎的表。

  通过这两种方式查询的表称之为**常量表（Constant Tables）**，优化器在分析一个查询语句时，首先执行常量表查询，然后把查询中涉及到该表的条件全部替换成常数，最后再分析其余表的查询成本。例如：

  ```mysql
  -- 明显的，table1 表便是常量表
  SELECT * FROM table1 INNER JOIN table2
      ON table1.column1 = table2.column2 
      WHERE table1.primary_key = 1;
  ```

  在分析 table2 表的查询成本前，就会对 table1 执行查询，把其中涉及到 table1 表的条件全部替换，像这样：

  ```mysql
  SELECT 
  	table1表记录的各个字段的常量值,
  	table2.* FROM table1 INNER JOIN table2 ON table1表column1列的常量值 = table2.column2;
  ```

<br />

## 外连接消除

---

左、右外连接驱动表和被驱动表是固定的，但是内连接却与之相反，这也就是说，内连接可能可以通过优化表的连接顺序来降低整体的查询成本，但外连接不行。

那么有没有一种转换，可以把外连接转换成内连接从而使得外连接也可以通过优化表的连接顺序来降低整体的查询成本呢？

有的，首先我们看左、右外连接，查询优化器如何对待它们。

由于左、右外连接只是在驱动表选取上不同，其余方面相同，所以查询优化器会首先把右外连接转换成左外连接查询，这样呢，左、右外连接就可以统一了，我们就可以只探寻，外连接和内连接是如何转换的了。

我们知道对于关键字 ON ，内、外连接使用是效果不同的，但是对于关键字 WHERE ，内、外连接的效果都一致，那就是**凡是不符合WHERE子句中条件的记录都不会参与连接。**

对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，且被驱动表相关列的值为 NULL ；而内连接的驱动表的记录如果无法在被驱动表中找到匹配ON子句中的过滤条件的记录，那么该记录会被舍弃。

救赎之道就在其中，NULL ！我们只需要将被驱动表相关列的值为 NULL 的记录在外连接结果集中排除，就可以达成外连接和内连接的相互转换！

如何排除，当然是使用 WHERE 关键字了。这一种在外连接查询中，指定的 WHERE 子句中包含被驱动表中的列不为 NULL 值的条件称之为**空值拒绝（Reject-NULL）**。

那么如何用关键字 WHERE 指定包含被驱动表中的列不为 NULL 值呢？直接间接的都行，例如：

```mysql
-- 直接
WHERE 被驱动表列n1 IS NOT NULL;

-- 间接，假设 被驱动表列n1 数据类型是 INT
WHERE 被驱动表列n1 = 2
```

在被驱动表的 WHERE 子句符合空值拒绝的条件后，外连接和内连接可以相互转换。查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

<br />

## 子查询优化

---

出现在某个查询语句的某个位置中的查询被称为**子查询**，而这个某个查询，就是**外层查询。**子查询可以在对应外层查询的各种位置出现，例如：

* SELECT 子句中。

  ```mysql
  SELECT (SELECT m1 FROM t1 LIMIT 1);
  ```

* FROM 子句中。

  ```mysql
  -- 子查询结果集组成的表称之为派生表，下面的 t 表便是派生表
  SELECT m, n FROM (SELECT m2 + 1 AS m, n2 AS n FROM t2 WHERE m2 > 2) AS t;
  ```

* WHERE 或 ON 子句中。

  ```mysql
  SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
  ```

* ORDER BY 子句中。

* GROUP BY 子句中。

<br />

### 按返回的结果集区分子查询

---

按返回的不同结果集类型，把子查询分为不同的类型，如下：

* 标量子查询。即只返回一个单一值的子查询，这个单一的值，也被称为**标量**。

  ```mysql
  -- 例1：子查询返回 t1 表一条记录的 m1 列的值
  SELECT (SELECT m1 FROM t1 LIMIT 1);
  
  -- 例2：子查询返回 t2 表 m2 列的最小值
  SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);
  ```

* 行子查询。即只返回一条记录的子查询，但这条记录包括多个列。

  ```mysql
  -- 例：子查询返回 t2 表一条记录的 m1 和 n1 列的值
  SELECT * FROM t1 WHERE (m1, n1) = (SELECT m2, n2 FROM t2 LIMIT 1);
  ```

* 列子查询。即返回一个列多条记录的子查询，不能只返回一条记录，否则是标量子查询。

  ```mysql
  -- 例：子查询返回 t2 表多条记录的 m2 列的值
  SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);
  ```

* 表子查询。即返回多条记录，每条记录包含多个列的子查询。

  ```mysql
  -- 例：子查询返回 t2 表的多条记录，每条记录包含 m2 和 n2 列的值
  SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);

