# Mysql是怎样运行的：第九章笔记

---

## 前言

本章内容偏向概念，建议顺序阅读不要跳读。

**注意：未特殊说明，本章中所介绍的所有结构的对应字段都按对应序号从上至下排列。**

<br />

## 笔记正文

---

### 回忆一些旧知识

---

InnoDB 是以页为单位管理存储空间的，我们的聚簇索引（即完整的表数据）和其他的二级索引都是以 B+ 树的形式保存到表空间的，而 B+ 树的节点就是数据页。

InnoDB 也为了不同的目的设计了若干种不同类型的页，常用的页类型如下：

|        类型名称         | 十六进制 |         描述          |
| :---------------------: | :------: | :-------------------: |
| FIL_PAGE_TYPE_ALLOCATED |  0x0000  |  最新分配，还没使用   |
|    FIL_PAGE_UNDO_LOG    |  0x0002  |      Undo日志页       |
|     FIL_PAGE_INODE      |  0x0003  |      段信息节点       |
| FIL_PAGE_IBUF_FREE_LIST |  0x0004  | Insert Buffer空闲列表 |
|  FIL_PAGE_IBUF_BITMAP   |  0x0005  |   Insert Buffer位图   |
|    FIL_PAGE_TYPE_SYS    |  0x0006  |        系统页         |
|  FIL_PAGE_TYPE_TRX_SYS  |  0x0007  |     事务系统数据      |
|  FIL_PAGE_TYPE_FSP_HDR  |  0x0008  |    表空间头部信息     |
|   FIL_PAGE_TYPE_XDES    |  0x0009  |      扩展描述页       |
|   FIL_PAGE_TYPE_BLOB    |  0x000A  |        BLOB页         |
|     FIL_PAGE_INDEX      |  0x45BF  |   索引页，即数据页    |

对于页，一个页的大小一般是 16KB 。所有类型的页都有两个通用部分，File Header 和 File Trailer ，前者占页的 38 个字节，后者占页的 8 个字节。

<br />

#### File Header

----

对于 File Header（页面头部），我们首先回顾下他的组成部分：

|               名称               | 占用空间大小 |                             描述                             |
| :------------------------------: | :----------: | :----------------------------------------------------------: |
|     FIL_PAGE_SPACE_OR_CHKSUM     |    4 字节    |                   页的校验和（checksum值）                   |
|         FIL_PAGE_OFFSET          |    4 字节    |                             页号                             |
|          FIL_PAGE_PREV           |    4 字节    |                        上一个页的页号                        |
|          FIL_PAGE_NEXT           |    4 字节    |                        下一个页的页号                        |
|           FIL_PAGE_LSN           |    8 字节    | 页被最后修改时对应的日志序列位置（英文名是：Log Sequence Number） |
|          FIL_PAGE_TYPE           |    2 字节    |                          该页的类型                          |
|     FIL_PAGE_FILE_FLUSH_LSN      |    8 字节    | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID |    4 字节    |                       页属于哪个表空间                       |

接下来我们解释几个重要的名词：

1. 校验和：对于一个很长的字节串而言，我们会通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为校验和。在比较两个长字节串之前先比较这两个长字节串的校验和，如果校验和都不一样两个长字节串肯定是不同的省去了直接比较两个比较长的字节串的时间损耗。
2. LSN：暂时不了解没关系。

最后我们简述一下 File Header（页面头部）的作用，即记录页的一些通用信息。

<br />

#### File Trailer

----

对于 File Trailer ，这一部分由 8 个字节组成，可以分成两个部分：

1. 前4个字节代表页的校验和。
2. 后4个字节代表页面被最后修改时对应的日志序列位置（LSN）。

File Trailer 的作用是为了校验页的完整性。InnoDB 存储引擎会以页为单位把数据加载到内存中处理，若该页中的数据在内存中被修改了，需要在修改后的某个时间需要把数据同步到磁盘中。但是在同步未完成时中断了怎么办呢？File Trailer 就开始发挥他的作用了。

每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来。 File Header 的校验和会首先被同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。若不一致，则同步出错，此时， File Header 中的校验和代表已经修改过的页，File Trailer 中的校验和代表原先的页。

**注意：LSN 和 校验和的作用都是为了校验页的完整性。**

同样，我们简述一下 File Trailer 的作用，即校验页是否完整，保证从内存到磁盘刷新时内容的一致性。

<br />

#### 最后的强调

---

对于上面的知识，我们需要强调以下几点：

1. 表空间中的每一个页都对应着一个页号，页号由 4 个字节组成（即一个表空间最多可以拥有 2³² 个页），若按页的默认大小 16KB 来算，一个表空间最多支持 64TB（2³² * 16KB）的数据。表空间的第一个页的页号为0，之后的页号分别是1，2，3...依此类推。
2. FIL_PAGE_PREV 和 FIL_PAGE_NEXT 来存储上一个页和下一个页的页号，但是这两个字段主要是为了 FIL_PAGE_INDEX 类型的页，一般类型的页是不使用这两个字段的。
3. FIL_PAGE_TYPE 字段的值表示为十六进制，例如数据页的该字段的值就是 0x45BF 。

<br />

### 独立表空间结构

---

#### 区（extent）的概念

---

对于 16KB 的页而言，连续的 64 个页就是一个**区**，一个区的大小为 1MB （64 * 16KB）。在区之上，还有**组**，每 256 个区被划分成一组。

例如，extent 0 ~ extent 255 这 256 个区为第一个组，extent 256 ~ extent 511 这 256 个区算是第二个组，以此类推。

**注意：不论是系统表空间还是独立表空间，都可以看成是由若干个区组成的，即表空间被划分为许多连续（这个连续非常重要）的区。**

综上所述，表空间的层级结构由大到小依次为：表空间、组、区、页。

表空间的**第一个组**的最开始的 3 个页的类型是固定的，**其他组**的最开始的 2 个页的类型也是固定的。对于第一个组，最开始的 3 个页的类型介绍按顺序依次如下：

1. FIL_PAGE_TYPE_FSP_HDR：这个类型的页用来登记整个表空间的一些整体属性以及本组所有的区的属性。

   **注意：整个表空间只有一个 FIL_PAGE_TYPE_FSP_HDR 类型的页。**

2. FIL_PAGE_IBUF_BITMAP：这个类型的页用来存储本组所有区的所有页关于 INSERT BUFFER 的信息。

3. FIL_PAGE_INODE：这个类型的页用来存储许多称为 INODE 的数据结构。

其余各组的最开始的 2 个页的类型介绍按顺序依次如下：

1. FIL_PAGE_TYPE_XDES：XDES 全称是 Extent Descriptor。这个类型的页用来登记本组256个区的属性。和 FIL_PAGE_TYPE_FSP_HDR 类型的页作用相似，但是 FIL_PAGE_TYPE_FSP_HDR 类型的页还会额外存储一些表空间的属性。
2. FIL_PAGE_IBUF_BITMAP：上文已介绍。

<br />

#### 段（segement）的概念

---

段（segement）是某些零散的页以及一些完整的区的集合。

零散的页来自于碎片（fragment）区，碎片区中的页，不是所有的都是为了存储同一个段的数据而存在的，而是可以被用于不同的目的。例如：有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

为某个段分配存储空间的策略是这样的：

* 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页为单位来分配存储空间的。
* 当某个段已经占用了 32 个碎片区页之后，就会以完整的区为单位来分配存储空间。

从上文来看，表空间的层级结构可以更新为：表空间、组、段、区、页。

段的这一概念，在数据量庞大的时候非常有用。但是在理解段之前，我们还需要回顾一下区。

还记得这句话吗？

> 表空间被划分为许多连续的区。

连续一词在这句话中十分重要，为什么？

我们知道，在聚簇索引中，B+ 树的每一层中的页都会形成一个双向链表，如果以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。

这意味着什么？举个例子，在 B+ 树索引的范围查询中，我们虽然只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以查询出我们的结果。但是由于两个页之间的物理位置十分遥远，顺序I/O 就会变成 随机I/O，性能大大降低！

所以区的概念诞生了，连续的 64 个页就是一个区，这个连续就是在物理位置上连续。

因为区的存在，在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配。但这是不是有点用空间换时间的味道？从结果来看，是功大于过的。

在 InnoDB 中，B+ 树的叶子节点和非叶子节点都有自己独有的区。因为不区分开统统放入分配好空间的区中的话，以范围扫描为例，效果大打折扣。

B+ 树叶子节点独有的区组成的集合可以被称为一个段，B+ 树非叶子节点独有的区组成的集合也可以被称为一个段。也就是说，一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。除了索引的叶子节点段和非叶子节点段之外，InnoDB 中还有为存储一些特殊的数据而定义的段，比如回滚段。

但是，段（segement）不是某些零散的页以及一些完整的区的集合吗？这里可以回顾一下为某个段分配存储空间的策略。为什么在刚开始向表中插入数据的时候，段是从某个碎片区以单个页为单位来分配存储空间的？为什么在集齐32个碎片区页之后，才会以完整的区为单位来分配存储空间？

一开始用完整的区为单位进行分配不就行了吗？

虽然说空间换时间，但也不能大量浪费空间。若是以完整的区为单位来分配存储空间，一个区默认大小是 1M，一个索引会生成两个段，也就是说一个索引至少要 2M 的空间。数据填满了整个区还好说。数据少的情况下浪费的空间有多少我想都不敢想。

为了避免这种情况，碎片区诞生了。随之，段也诞生了。

<br />

#### 区的分类

---

区可以分为四种类型，或者说这四种类型为区的四种状态。

|  状态名   |         含义         |                            释义                            |
| :-------: | :------------------: | :--------------------------------------------------------: |
|   FREE    |       空闲的区       |               现在还没有用到这个区中的任何页               |
| FREE_FRAG |  有剩余空间的碎片区  |                  表示碎片区中还有可用的页                  |
| FULL_FRAG | 没有剩余空间的碎片区 |          表示碎片区中的所有页都被使用，没有空闲页          |
|   FSEG    |   附属于某个段的区   | 附属于某个段的区。如 B+ 树叶子节点独有的区附属于叶子节点段 |

处于 FREE、FREE_FRAG 以及 FULL_FRAG 这三种状态的区都是独立的，算是直属于表空间。而处于 FSEG 状态的区是附属于某个段的。

XDES Entry 结构（全称 Extent Descriptor Entry），用于管理这些区，XDES Entry 结构和区是一对一的关系。

XDES Entry 结构记录了对应的区的一些属性，他的组成情况如下：

1. Segment ID（8字节）：当对应区已经被分配给某个段了，该字段的值表示该区所在的段。

   **注意：每一个段都有一个唯一的编号，用ID表示。**

2. List Node（12字节）：这个部分由四个字段组成，分别是 Pre Node Page Number 和 Pre Node Offset ，还有 Next Node Page Number 和 Next Node Offset 。

   这个部分可以将若干个 XDES Entry 结构串联成一个链表。

   Pre Node Page Number 和 Pre Node Offset 的组合就是指向前一个 XDES Entry 的指针。 

   Next Node Page Number 和 Next Node Offset 就是指向后一个 XDES Entry 的指针。

3. State（4字节）：区的状态。有四个值分别是 FREE、FREE_FRAG、FULL_FRAG 和 FSEG。

4. Page State Bitmap（16字节）：默认情况下，对于一个区而言，有 64 个页，每个页占当前字段的的两个比特位（16 字节 = 64 * 2 bit）。例如，Page State Bitmap 部分的第1和第2个比特位对应着区中的第1个页。这两个比特位的第一个位表示对应的页是否是空闲的，第二个比特位还没有用。

<br />

#### XDES Entry 链表

---

先打下一个基调，XDES Entry 结构和区是一对一的关系。然后，让我们再次回顾一下向某个段中插入数据的过程：

1. 当段中数据较少的时候，首先会在表空间中寻找还有空闲空间的碎片区（FREE_FRAG 状态的区）。如果找到了，就从该区中取一些零碎的页把数据插进去。否则到表空间下申请一个状态为空闲的区（FREE 状态的区），把该区的状态变为 FREE_FRAG ，然后从该新申请的区中取一些零碎的页把数据插进去。之后不同的段使用零碎页的时候都会从该区中取，直到该区中没有空闲空间，该区的状态就变成了 FULL_FRAG ，即没有剩余空间的碎片区。

2. 当段中数据已经占满了 32 个零散的页后，就直接申请完整的区来插入数据。

现在，摆在我们面前的有两个问题：

1. 如何在表空间中寻找状态为 FREE_FRAG 状态的区？
2. 我们怎么知道哪些区属于哪个段的呢？

简单粗暴一点思路就是完全遍历，从头到尾！遍历对上述两个问题都是一个解决方案，但是对于数据量大的时候呢？

这时候我们就不得不转换思路了，从既有的数据结构下手，找到突破点。

既然 XDES Entry 结构和区是一对一的关系，并且 XDES Entry 结构中有一个部分是 List Node 。链表！我们可以通过维护链表来解决上述两个问题！

是的，链表，设计 InnoDB 的大佬们就是这么做的。

**直属于表空间的，有 3 个链表。**分别是：

* FREE 链表：把状态为 FREE 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表。
* FREE_FRAG 链表：把状态为 FREE_FRAG 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表。
* FULL_FRAG 链表：把状态为 FULL_FRAG 的区对应的 XDES Entry 结构通过 List Node 来连接成一个链表。

**附属于某个段的，也有 3 个链表。**分别是：

* FREE 链表：同一个段中，所有页都是空闲的区对应的 XDES Entry 结构会被加入到这个链表。注意这个链表附属于某个段而不是直属于表空间。
* NOT_FULL 链表：同一个段中，仍有空闲空间的区对应的 XDES Entry 结构会被加入到这个链表。
*  FULL 链表：同一个段中，已经没有空闲空间的区对应的 XDES Entry 结构会被加入到这个链表。

如何使用这些链表？举两个例子：

1. 每当我们想找一个 FREE_FRAG 状态的区时，就直接把 FREE_FRAG 链表的头节点拿出来，从这个节点中取一些零碎的页来插入数据，当这个节点对应的区用完时，就修改一下这个节点的 State 字段的值，然后从 FREE_FRAG 链表中移到 FULL_FRAG 链表中。如果 FREE_FRAG 链表中一个节点都没有，那么就直接从 FREE 链表中取一个节点移动到 FREE_FRAG 链表的状态，并修改该节点的 STATE 字段值为 FREE_FRAG ，然后从这个节点对应的区中获取零碎的页就好了。其他的情况以此类推。
2. 段在数据量比较大时插入数据的话，会先获取 NOT_FULL 链表的头节点，直接把数据插入这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移到 FULL 链表中。

那么，对于一个拥有两个索引、使用独立表空间的表，它需要维护多少个链表呢？

答案是：2（两个索引）* 2（一个索引有两个段）* 3（每个段维护三个链表）+ 3（直属于表空间的3个链表） = 15 个。

<br />

#### 链表基节点

---

List Base Node 的结构，即链表基节点，他与链表是一对一的关系，他的作用是帮我们找到对应的链表。

我们已经知道，直属于表空间的或者附属于某个段的链表的存在，那么我们怎么在表空间中找到他们呢？链表基节点给出了答案，他的结构如下：

1. List Length：表明该链表一共有多少节点。
2.  First Node Page Number 和 First Node Offset 字段表明该链表的头节点在表空间中的位置，即这两个字段指向 XDES Entry 链表头节点的指针。
3. Last Node Page Number 和 Last Node Offset 字段表明该链表的尾节点在表空间中的位置，即这两个字段指向 XDES Entry 链表尾节点的指针。

一般我们把某个链表对应的 List Base Node 结构放置在表空间中固定的位置，因此，找到某个链表的位置就变得十分简单了。

<br />

#### 段的结构

---

**段不对应表空间中某一个连续的物理区域。**

像 XDES Entry 结构和区是一对一的关系，并且 XDES Entry 结构记录了对应的区的一些属性一样。INODE Entry 结构与段也是一对一的关系，并且 INODE Entry 结构记录了对应的段中的属性。他的结构如下：

1. Segment ID（8 字节）：指这个 INODE Entry 结构对应的段的编号（ID）。
2. NOT_FULL_N_USED（4 字节）：指的是在 NOT_FULL 链表中已经使用了多少个页。下次从 NOT_FULL 链表分配空闲页时可以直接根据这个字段的值定位到，而不用从链表中的第一个页开始遍历着寻找空闲页。
3. 3个 List Base Node 字段（每个 16 字节，共 48 字节）：即分别为段的 FREE 链表、 NOT_FULL 链表、FULL 链表定义的 List Base Node ，可以帮助我们快速的找到对应链表的位置。
4. Magic Number（4 字节）：用来标记这个 INODE Entry 是否已经被初始化了（即 INODE Entry 结构各个字段的值是否已经填入）。如果这个字段的值是 97937874 （该值无意义，只是规定），表示已初始化，否则没有初始化。
5. 32 个 Fragment Array Entry 字段（每个 4 字节，共 128 字节）：每个 Fragment Array Entry 结构都对应着一个零散的页，表示一个零散页的页号。

<br />

#### 各类型页详细情况

---

##### FIL_PAGE_TYPE_FSP_HDR 类型

---

表空间第一个组的第一个页（即表空间的第一个页，页号为 0，此类型的页表空间里仅有一个），页的类型为   FIL_PAGE_TYPE_FSP_HDR 。 它存储了表空间的一些整体属性以及第一个组内256个区的对应的 XDES Entry 结构。结构如下：

|       名称        |    中文名    | 占用空间大小 |             简单描述             |
| :---------------: | :----------: | :----------: | :------------------------------: |
|    File Header    |   文件头部   |   38 字节    |         页的一些通用信息         |
| File Space Header |  表空间头部  |   112 字节   |     表空间的一些整体属性信息     |
|    XDES Entry     |  区描述信息  |  10240 字节  |  存储本组256个区对应的属性信息   |
|    Empty Space    | 尚未使用空间 |  5986 字节   | 用于页结构的填充，没什么实际意义 |
|   File Trailer    |   文件尾部   |    8 字节    |          校验页是否完整          |

XDES Entry 字段存储本组256个区对应的属性信息，占用了10240 字节，我们来计算一下。

我们知道 256 个区组成一个组，XDES Entry 结构和区是一对一的关系。在 FIL_PAGE_TYPE_FSP_HDR 类型的页中，每个 XDES Entry 结构占用 40 字节。那么 XDES Entry 字段占用的字节数就是 256 * 40 = 10240 个字节。 

**注意：再重申一遍，XDES Entry 结构记录了对应的区的一些属性。**

<br />

###### File Space Header 部分

---

这一部分被用来存储表空间的一些整体属性信息，他的结构如下：

1. Space ID（4 字节）：表空间的ID。

2. Not Used（4 字节）：这4个字节未被使用，可以忽略。

3. Size（4 字节）：当前表空间占有的页数。

4. FREE Limit（4 字节）：尚未被初始化的最小页号，大于或等于这个页号的区对应的XDES Entry结构都没有被加入FREE链表。

   这里涉及到了表空间的初始化操作，具体表现为：为表空间中的区建立 XDES Entry 结构，为各个段建立 INODE Entry 结构，建立各种链表等等各种操作。

   表空间在初始化建立 FREE 链表时，可以选择把所有的空闲区对应的 XDES Entry 结构加入 FREE 链表，也可以只把一部分的空闲区加入 FREE 链表，等到 FREE 链表中的 XDES Entry 结构对应的区不够使了，再把之前没有加入 FREE 链表的空闲区对应的 XDES Entry 结构加入 FREE 链表。InnoDB 的设计者采用这种方式，其思想就是什么时候用到什么时候初始化。他们为表空间定义了 FREE Limit 这个字段，在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化。

5. Space Flags（4 字节）：表空间一些占用存储空间比较小的属性存储在其中，如布尔类型的属性或一些只有几个比特位的属性。虽然这个字段很小，但是存储了很多表空间的属性。

   不同的MySQL版本，SPACE_FLAGS 代表的属性可能不同，以 5.7.21 版本为例：

   |   标志名称    | 占用的空间 |                    描述                    |
   | :-----------: | :--------: | :----------------------------------------: |
   | POST_ANTELOPE |   1 bit    |       表示文件格式是否大于 ANTELOPE        |
   |   ZIP_SSIZE   |   4 bit    |              表示压缩页的大小              |
   | ATOMIC_BLOBS  |   1 bit    | 表示是否自动把值非常长的字段放到 BLOB 页里 |
   |  PAGE_SSIZE   |   4 bit    |                   页大小                   |
   |   DATA_DIR    |   1 bit    |  表示表空间是否是从默认的数据目录中获取的  |
   |    SHARED     |   1 bit    |              是否为共享表空间              |
   |   TEMPORARY   |   1 bit    |              是否为临时表空间              |
   |  ENCRYPTION   |   1 bit    |               表空间是否加密               |
   |    UNUSED     |   18 bit   |             没有使用到的比特位             |

6. FRAG_N_USED（4 字节）：表示在 FREE_FRAG 链表中已经使用的页数量，方便之后在链表中查找空闲的页。

7.  List Base Node for FREE List 、List Base Node for FREE_FRAG List 和 List Base Node for FULL_FRAG List 字段（每个字段 16 字节）：上述三个字段分别代表着：直属于表空间的 FREE 链表的基节点、 FREE_FRAG 链表的基节点和 FULL_FRAG 链表的基节点。一般我们把某个链表对应的 List Base Node 结构放置在表空间中固定的位置。**是的，直属于表空间的三个链表的基结点，放置在表空间的第一个类型为 FIL_PAGE_TYPE_FSP_HDR 的页的 File Space Header 字段中。**

8. Next Unused Segment ID（8 字节）：表示当前表空间中下一个未使用的 Segment ID。这个字段是为了解决新创建一个段，它的 ID 取值的问题。我们当然不愿意遍历所有的段来确定新创建段的 ID 值。所以，根据这个字段，我们可以直接把该字段的值作为新字段的 ID 值。

   **注意：每个段都有一个唯一的ID。**

9. List Base Node for SEG_INODES_FULL List 和 List Base Node for SEG_INODES_FREE List 字段（每个字段 16 字节）：

   首先，我们知道 INODE Entry 结构与段也是一对一的关系。

   其次，每个段对应的 INODE Entry 结构会集中存放到一个类型为 INODE 的页中。

   那么，当一个类型为 INODE 的页放不下更多的 INODE Entry 结构的时候，我们就会生成很多的 INODE 类型的页来进行存放。这时，这些 INODE 类型的页就会组成两个链表：

   * SEG_INODES_FULL 链表：该链表中的 INODE 类型的页都已经被 INODE Entry 结构填充满了，没空闲空间存放额外的 INODE Entry 结构了。
   * SEG_INODES_FREE 链表：该链表中的 INODE 类型的页仍有空闲空间来存放 INODE Entry 结构。

   两个链表对应的基结点分别是：List Base Node for SEG_INODES_FULL List 和 List Base Node for SEG_INODES_FREE List ，可见，基结点的位置是固定的，所以我们可以很轻松的访问到这两个链表。

   **注意： INODE 类型的页即FIL_PAGE_INODE 类型的页。**

   <br />

###### XDES Entry 部分

---

**XDES Entry 结构，就是在表空间每组的第一个页中进行保存的。**我们把 256 个区划分为一组，也就意味着，表空间每组的第一个页中存放了 256 个 XDES Entry 结构。同时，这也就意味着，**每个区对应的 XDES Entry 结构的地址是固定的**，访问这些结构就变得非常简单了。

<br />

##### FIL_PAGE_TYPE_XDES 类型

---

FIL_PAGE_TYPE_FSP_HDR 类型的页去除掉 File Space Header 部分，就是 FIL_PAGE_TYPE_XDES 类型的页。

在这里我们重申一下 File Space Header 部分的作用，它被用来存储表空间的一些整体属性信息。也就是说，FIL_PAGE_TYPE_XDES 类型的作用仅仅只是记录本组内所有的区对应的 XDES Entry 结构。

**FIL_PAGE_TYPE_FSP_HDR 类型的页在整个表空间里只有一个**，它记录着表空间第一个组所有区对应的 XDES Entry 结构和表空间的一些整体属性。那么，除去第一个分组以外，之后的每个分组的第一个页我们想用一个类型的页记录组内所有区对应的 XDES Entry 结构，但不需要再记录表空间的属性（重复记录没必要），用FIL_PAGE_TYPE_XDES 类型页即可。

<br />

##### FIL_PAGE_IBUF_BITMAP 类型

---

表空间每个分组的第二个页的类型都是 FIL_PAGE_IBUF_BITMAP 类型，这种类型的页里边记录了一些有关 Change Buffer 信息。至于 Change Buffer 是什么，我们后面展开。

<br />

##### FIL_PAGE_INODE 类型

---

**FIL_PAGE_INODE 类型的页就是为了存储 INODE Entry 结构而存在的。**

他的结构如下：

|             名称              |    中文名    | 占用空间大小 |                 简单描述                  |
| :---------------------------: | :----------: | :----------: | :---------------------------------------: |
|          File Header          |   文件头部   |   38 字节    |             页的一些通用信息              |
| List Node for INODE Page List | 通用链表节点 |   12 字节    | 存储上一个 INODE 页和下一个 INODE页的指针 |
|          INODE Entry          |  段描述信息  |  16320 字节  |                                           |
|          Empty Space          | 尚未使用空间 |    6 字节    |     用于页结构的填充，没什么实际意义      |
|         File Trailer          |   文件尾部   |    8 字节    |              校验页是否完整               |

对于 List Node for INODE Page List 字段的结构，如下：

* Prev Node Page Number（4 字节）
* Prev Node Offset（2 字节）
* Next Node Page Number（4 字节）
* Next Node Offset（2 字节）

对于 INODE Entry 字段占用了 FIL_PAGE_INODE 类型的页的 16320 字节的大小，我们来计算一下它。

我们知道 INODE Entry 结构与段也是一对一的关系，在 FIL_PAGE_INODE 类型的页中，每个 INODE Entry 结构占用 192 字节，一共有 85 个 INODE Entry，所以 85 * 192 Byte =  16,320 Byte 。

最后，让我们看看存储 INODE Entry 的大致过程：

我们已知 INODE 类型的页会组成两个链表，分别是 SEG_INODES_FULL 链表和 SEG_INODES_FREE 链表。

* 若 SEG_INODES_FREE 链表不为空，直接从该链表中获取一个节点（即获取到一个仍有空闲空间的 FIL_PAGE_INODE 类型的页），然后把该 INODE Entry 结构放到该页中。当该页中无剩余空间时，就把该页作为一个节点放到 SEG_INODES_FULL 链表中。
* 若 SEG_INODES_FREE 链表为空，则从表空间的 FREE_FRAG 链表中申请一个页，修改该页的类型为 FIL_PAGE_INODE 类型，然后把该页放到 SEG_INODES_FREE 链表中，同时，把该 INODE Entry 结构放入该页。

**注意：创建一个索引，就会创建两个段，每个段对应一个 INODE Entry 结构，INODE Entry 结构会被存放进 FIL_PAGE_INODE 类型的页中。**

<br />

#### Segment Header 结构的运用

---

FIL_PAGE_INDEX 类型的页（即索引页，又称数据页）的存储空间，大致被划分为了 7 个部分。其中，有一个部分名为 Page Header（即页面头部，占 56 字节），记录了一些索引页专有的信息。

Page Header 部分的结构中，含有两个字段，分别是 PAGE_BTR_SEG_LEAF（占 10 字节）和 PAGE_BTR_SEG_TOP（占 10 字节）。前者记录 B+ 树叶子段的头部信息，后者记录 B+ 树非叶子段的头部信息，两者都仅在 B+ 树的 Root 页定义。

**注意：一个索引会产生两个段，分别是叶子节点段和非叶子节点段。**

为什么我们要提上面的概念？有没有发现，段和 INODE Entry 结构还没有完全对应上，我们如何知晓某个 INODE Entry 结构对应哪一个段呢？

索引页给出了答案，它含有的 Page Header 部分对应的 PAGE_BTR_SEG_LEAF、 PAGE_BTR_SEG_TOP 两个字段，分别对应一个 Segment Header 结构，这个结构如下：

|              名称              | 占用字节数 |               描述               |
| :----------------------------: | :--------: | :------------------------------: |
|  Space ID of the INODE Entry   |   4 字节   |  INODE Entry 结构所在的表空间ID  |
| Page Number of the INODE Entry |   4 字节   |   INODE Entry 结构所在的页页号   |
|  Byte Offset of the INODE Ent  |   2 字节   | INODE Entry 结构在该页中的偏移量 |

也就是说，PAGE_BTR_SEG_LEAF 记录着叶子节点段对应的 INODE Entry 结构的地址是哪个表空间的哪个页的哪个偏移量，PAGE_BTR_SEG_TOP 记录着非叶子节点段对应的 INODE Entry 结构的地址是哪个表空间的哪个页的哪个偏移量。

现在，我们就打通了索引到 INODE Entry 结构的路。

通过索引页 Page Header 部分的 PAGE_BTR_SEG_LEAF、 PAGE_BTR_SEG_TOP 两个字段，我们可以找到索引的两个节点段（叶子节点段和非叶子节点段）对应的两个 INODE Entry 结构。

**注意：因为一个索引只对应两个段，所以只需要在索引的 Root 页中记录这两个 INODE Entry 结构即可。**

<br />

#### 真实表空间对应的文件大小

---

使用独立表空间建立的表（未含有任何数据）在数据目录中对应的`.ibd`文件只占用 96 KB（6 个页的大小）。

同时，因为`.ibd`文件是自扩展的，所以随着表中数据的增加，表空间对应的文件也会越来越大。

<br />

### 系统表空间

---

整个 MySQL 进程只有一个系统表空间，系统表空间会额外记录一些有关整个系统信息的页。

系统表空间是表空间之首，他的表空间 ID（Space ID）是 0 。

<br />

#### 系统表空间的整体结构

---

**系统表空间与独立表空间的一个非常明显的区别就是系统表空间在表空间开头有许多记录整个系统属性的页。**

系统表空间与独立表空间的前三个页的类型一致，但是从第四个页开始到第八个页（页号3 到 页号7），就是系统表空间特有的页了（这些页记录了系统属性），我们来看看这些页：

| 页号 | 页类型  |        英文描述        |           中文描述            |
| :--: | :-----: | :--------------------: | :---------------------------: |
|  3   |   SYS   |  Insert Buffer Header  | 存储 Insert Buffer 的头部信息 |
|  4   |  INDEX  |   Insert Buffer Root   | 存储 Insert Buffer 的 Root 页 |
|  5   | TRX_SYS |   Transction System    |      事务系统的相关信息       |
|  6   |   SYS   | First Rollback Segment |       第一个回滚段的页        |
|  7   |   SYS   | Data Dictionary Header |       数据字典头部信息        |

除了上述记录系统属性的页之外，系统表空间的 extent 1 和 extent 2 这两个区（页号64 ~ 页号 191 的 128 个页）被称为**双写缓冲区**。

<br />

#### InnoDB 数据字典

---

MySQL除了保存我们插入的用户数据之外，还需要保存许多额外的信息。例如，某个表属于哪个表空间，表里边有多少列，表对应的每一个列的类型是什么。这些个额外的信息被称为**元数据**，这些元数据被 InnoDB 存储引擎特意定义的一些列的**内部系统表（Internal System Table）**存储：

|       表名       |                             描述                             |
| :--------------: | :----------------------------------------------------------: |
|    SYS_TABLES    |             整个 InnoDB 存储引擎中所有的表的信息             |
|   SYS_COLUMNS    |             整个 InnoDB 存储引擎中所有的列的信息             |
|   SYS_INDEXES    |            整个 InnoDB 存储引擎中所有的索引的信息            |
|    SYS_FIELDS    |        整个 InnoDB 存储引擎中所有的索引对应的列的信息        |
|   SYS_FOREIGN    |            整个 InnoDB 存储引擎中所有的外键的信息            |
| SYS_FOREIGN_COLS |         整个 InnoDB 存储引擎中所有的外键对应列的信息         |
| SYS_TABLESPACES  |            整个 InnoDB 存储引擎中所有的表空间信息            |
|  SYS_DATAFILES   | 整个 InnoDB 存储引擎中所有的表空间对应文件系统的文件路径信息 |
|   SYS_VIRTUAL    |         整个 InnoDB 存储引擎中所有的虚拟生成列的信息         |

这些内部系统表也被称为**数据字典**。其中 SYS_TABLES、SYS_COLUMNS、SYS_INDEXES 和 SYS_FIELDS 表被称为**基本系统表（Basic System Tables）**，相当重要。

<br />

##### SYS_TABLES 表

---

SYS_TABLES 表结构如下：

|    列名    |                       描述                       |
| :--------: | :----------------------------------------------: |
|    NAME    |                     表的名称                     |
|     ID     |     InnoDB 存储引擎中每个表都有一个唯一的 ID     |
|   N_COLS   |                 该表拥有列的个数                 |
|    TYPE    | 表的类型，记录了一些文件格式、行格式和压缩等信息 |
|   MIX_ID   |                   已过时，忽略                   |
|  MIX_LEN   |                表的一些额外的属性                |
| CLUSTER_ID |                   未使用，忽略                   |
|   SPACE    |               该表所属表空间的 ID                |

该表有两个索引：

* 以 NAME 列为主键的聚簇索引。
* 以 ID 列建立的二级索引。

<br />

##### SYS_COLUMNS 表

---

SYS_COLUMNS 表结构如下：

|   列名   |                       描述                       |
| :------: | :----------------------------------------------: |
| TABLE_ID |               该列所属表对应的 ID                |
|   POS    |                该列在表中是第几列                |
|   NAME   |                    该列的名称                    |
|  MTYPE   |  Main Data Type，主数据类型，例如：INT、VARCHAR  |
|  PRTYPE  | Precise Type，精确数据类型，例如：是否允许NULL值 |
|   LEN    |           该列最多占用存储空间的字节数           |
|   PREC   | 该列的精度，不过这列貌似都没有使用，默认值都是0  |

该表只有一个索引：

* 以 (TABLE_ID,  POS) 列为主键的聚簇索引。

<br />

##### SYS_INDEXES 表

---

SYS_INDEXES 表结构如下：

|      列名       |                             描述                             |
| :-------------: | :----------------------------------------------------------: |
|    TABLE_ID     |                    该索引所属表对应的 ID                     |
|       ID        |          InnoDB 存储引擎中每个索引都有一个唯一的 ID          |
|      NAME       |                         该索引的名称                         |
|    N_FIELDS     |                      该索引包含列的个数                      |
|      TYPE       | 该索引的类型，比如聚簇索引、唯一索引、更改缓冲区的索引、全文索引、普通的二级索引等等 |
|      SPACE      |                该索引 Root 页所在的表空间 ID                 |
|     PAGE_NO     |                   该索引 Root 页所在的页号                   |
| MERGE_THRESHOLD | 如果页中的记录被删除到某个比例，就把该页和相邻页合并，这个值就是这个比例 |

该表只有一个索引：

* 以 (TABLE_ID, ID) 列为主键的聚簇索引。

<br />

##### SYS_FIELDS 表

---

SYS_FIELDS 表结构如下：

|   列名   |             描述             |
| :------: | :--------------------------: |
| INDEX_ID |   该索引列所属的索引的 ID    |
|   POS    | 该索引列在某个索引中是第几列 |
| COL_NAME |        该索引列的名称        |

该表只有一个索引：

* 以 (INDEX_ID, POS) 列为主键的聚簇索引。

<br />

##### Data Dictionary Header 页

---

**其他系统表以及用户定义的表的所有元数据都可以通过上述 4 个基本系统表获取。**

例如，我们想获取系统表 SYS_TABLESPACES 存储了哪些表空间以及表空间对应的属性，步骤如下：

1. 到 SYS_TABLES 表中根据表名定位到具体的记录，取得 SYS_TABLESPACES 表的 TABLE_ID 。
2. 使用 TABLE_ID 到 SYS_COLUMNS 表中获取到属于 SYS_TABLESPACES 表的所有列的信息。
3. 使用 TABLE_ID 到 SYS_INDEXES 表中获取到属于 SYS_TABLESPACES 表的所有索引的信息，信息中包含了 INDEX_ID（索引的 ID），还包含了索引对应的 B+ 树 Root 页是哪个表空间的哪个页。
4. 使用 INDEX_ID 到 SYS_FIELDS 表中获取所有索引列的信息。

但是，这 4 个基本系统表的元数据在哪获取呢？

这4个表的元数据（即有哪些列、哪些索引等信息）被硬编码到了代码中。在 InnoDB 中，有一个固定的页来记录这 4 个表的聚簇索引和二级索引对应的 B+ 树的位置。这个页是系统表空间中页号为 7 的页，他的页类型为 SYS ，记录了数据字典的头部信息（Data Dictionary Header）。当然，这个页除了记录基本系统表的 5 个索引的根页信息外，还记录了整个 InnoDB 存储引擎的一些全局属性，这个页的结构如下：

|          名称          |      中文名      | 占用空间大小 |                           简单描述                           |
| :--------------------: | :--------------: | :----------: | :----------------------------------------------------------: |
|      File Header       |     文件头部     |   38 字节    |                       页的一些通用信息                       |
| Data Dictionary Header | 数据字典头部信息 |   56 字节    | 记录一些基本系统表的根页位置以及 InnoDB 存储引擎的一些全局信息 |
|         Unused         |       没用       |    4 字节    |                        这4个字节没用                         |
|     Segment Header     |    段头部信息    |   10 字节    |          记录本页所在段对应的 INODE Entry 位置信息           |
|      Empty Space       |   尚未使用空间   |  16272 字节  |               用于页结构的填充，没什么实际意义               |
|      File Trailer      |     文件尾部     |    8 字节    |                        校验页是否完整                        |

InnoDB 把有关数据字典的信息当成一个段来分配存储空间，这个段被称为**数据字典段**。数据字典段有且仅有一个碎片页，即系统表空间中页号为 7 的页，这就是这个页结构的 Segment Header 字段的来龙去脉。

系统表空间中页号为 7 的页结构的 Data Dictionary Header 字段，结构如下：

1. Max Row ID（8 字节）：若未显式的为表定义主键，并且表中也无 UNIQUE 索引，那么 InnoDB 存储引擎会默认为表生成一个名为 row_id 的列作为主键。在拥有 row_id 列的表中插入一条记录的时候，该记录的 row_id 列的值就是当前 Max Row ID 字段的值，记录取走当前 Max Row ID 字段的值后，Max Row ID 字段的值会加一。

   **注意： Max Row ID 全局共享。**

2. Max Table ID（8 字节）： InnoDB 存储引擎中所有的表都对应一个唯一的 ID ，每次新建一个表时，就会把本字段的值作为该表的 ID ，然后自增本字段的值。

3. Max Index ID（8 字节）：InnoDB 存储引擎中所有的索引都对应一个唯一的 ID ，每次新建一个索引时，就会把本字段的值作为该索引的ID ，然后自增本字段的值。

4. Max Space ID（4 字节）：InnoDB 存储引擎中所有的表空间都对应一个唯一的 ID ，每次新建一个表空间时，就会把本字段的值作为该表空间的 ID ，然后自增本字段的值。

5. Mix ID Low(Unused) [4 字节]：这个字段没什么用，跳过。

6. Root of SYS_TABLES clust index（4 字节）：本字段代表 SYS_TABLES 表聚簇索引的 Root 页的页号。

7. Root of SYS_TABLE_IDS sec index（4 字节）：本字段代表 SYS_TABLES 表为 ID 列建立的二级索引的 Root 页的页号。

8. Root of SYS_COLUMNS clust index（4 字节）：本字段代表 SYS_COLUMNS 表聚簇索引的 Root 页的页号。

9. Root of SYS_INDEXES clust index（4 字节）：本字段代表 SYS_INDEXES 表聚簇索引的 Root 页的页号。

10. Root of SYS_FIELDS clust index（4 字节）：本字段代表 SYS_FIELDS 表聚簇索引的 Root 页的页号。

<br />

##### information_schema 系统数据库

----

**用户是不能直接访问 InnoDB 的内部系统表的。**但是我们分析问题可能需要用到内部系统表的信息，怎么办呢？

在系统数据库 information_schema 中，有一些以 INNODB_SYS 开头的表，便可以帮我们解决上述问题。

在切换到系统数据库 information_schema 后，我们可以通过如下命令查看相关的表：

```mysql
-- 查询出系统数据库 information_schema 中以 INNODB_SYS 开头的所有的表
SHOW TABLES LIKE 'innodb_sys%';
```

这些以 INNODB_SYS 开头的表，并不是真正的内部系统表（内部系统表以 SYS 开头），而是存储引擎启动时读取内部系统表，然后填充到这些以 INNODB_SYS 开头的表中。所以，以 INNODB_SYS 开头的表和以 SYS 开头的表中的字段并不完全一样，但对于分析问题足够了。

<br />

## 章节结束语

---

终于结束了，知识就像洪水一样被灌入了脑子不是吗？十分痛苦！但是摩天大楼也在你脑中建成，加油！
